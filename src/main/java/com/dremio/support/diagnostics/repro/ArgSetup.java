/**
 * Copyright 2022 Dremio
 *
 * <p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License at
 *
 * <p>http://www.apache.org/licenses/LICENSE-2.0
 *
 * <p>Unless required by applicable law or agreed to in writing, software distributed under the
 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.dremio.support.diagnostics.repro;

import static com.dremio.support.diagnostics.shared.zip.ArchiveDetection.isArchive;

import com.dremio.support.diagnostics.profilejson.ProfileJSONParser;
import com.dremio.support.diagnostics.repro.apiout.*;
import com.dremio.support.diagnostics.repro.consoleout.ConsoleOutput;
import com.dremio.support.diagnostics.repro.fileout.DirectoryOutput;
import com.dremio.support.diagnostics.repro.fileout.SqlDebugLogOutput;
import com.dremio.support.diagnostics.repro.fileout.ZipFileOutput;
import com.dremio.support.diagnostics.repro.parse.ArrowFormatDeserializer;
import com.dremio.support.diagnostics.repro.parse.ColumnDefYaml;
import com.dremio.support.diagnostics.repro.parse.ReproProfileParserImpl;
import com.dremio.support.diagnostics.repro.parse.SortTableDependencies;
import com.dremio.support.diagnostics.repro.parse.TableRefFinder;
import com.dremio.support.diagnostics.shared.*;
import com.dremio.support.diagnostics.shared.zip.UnzipperImpl;
import java.io.IOException;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.zip.ZipOutputStream;

/**
 * Args setup is a factory class that setups up dependencies for the Exec class based on the command
 * line arguments passed to dqd
 */
public class ArgSetup {

  // block instantiation as there are no instance methods
  private ArgSetup() {}

  /**
   * from the parameters passed in create the correct strategies for output writers.
   *
   * @param username dremio rest api username
   * @param password dremio rest api password
   * @param host location of dremio host without the trailing slash @link <a
   *     href="http://localhost:9047">http://localhost:9047</a> for example
   * @param zipOutput output zip file to use
   * @param outputDir the directory for file output, if null or empty no files will be written.
   * @param sqlDebugLog debugging log for profile reproduction. this will contain all dataset sql
   *     found in the profile
   * @param timeoutSeconds the number of seconds runSQL operations (create pds and vds) will wait to
   *     complete in api calls and in the scripts generated by the repro tool
   * @return an array of output strategies, this allows to combine args, if I provide hostname,
   *     password, host and the file the software will try and write to the API and a script and
   *     some sql to a directory
   * @throws IOException due to writing to a location that is not writeable or if the host is not
   *     accessible
   */
  public static SqlOutput[] getSqlOutput(
      final String username,
      final String password,
      final String host,
      final ZipOutputStream zipOutput,
      final String outputDir,
      String sqlDebugLog,
      int timeoutSeconds,
      String baseNasDir,
      boolean ignoreSSL)
      throws IOException {
    // make a list so we can do both api output and file output if both are requested
    List<SqlOutput> outputs = new ArrayList<>();
    if (sqlDebugLog != null && !sqlDebugLog.trim().equals("")) {
      outputs.add(new SqlDebugLogOutput(sqlDebugLog));
    }
    final FileMaker fileMaker;
    if (baseNasDir == null || "".equals(baseNasDir.trim())) {
      fileMaker = new SchemaDeserializer.TmpMaker();
    } else {
      fileMaker = new DirectoryMaker(baseNasDir);
    }
    if (username != null
        && !"".equals(username)
        && password != null
        && !"".equals(password)
        && host != null
        && !"".equals(host)) {
      HttpApiCall apiCall = new HttpApiCall(ignoreSSL);
      HttpAuth auth = new HttpAuth(username, password);
      DremioApi api = new DremioV3Api(apiCall, auth, host, fileMaker, timeoutSeconds);
      outputs.add(new ApiOutput(api));
    }
    // as long as this is not blank we will try and write to it
    if (zipOutput != null) {
      outputs.add(new ZipFileOutput(zipOutput, timeoutSeconds, fileMaker));
    }
    if (outputDir != null && !outputDir.isEmpty()) {
      outputs.add(new DirectoryOutput(Paths.get(outputDir), timeoutSeconds, fileMaker));
    }
    // if no options match, then just do console output so that at least something is generated
    if (outputs.isEmpty()) {
      outputs.add(new ConsoleOutput());
    }
    return outputs.toArray(new SqlOutput[0]);
  }

  /**
   * Decides to use zip or text parsers, would be the ideal place to add more formats
   *
   * @param pathAndStream path and stream of the json profile
   * @return either a zip reader or a text file reader depending on what type of file it is
   */
  public static ProfileProvider getProfileProvider(final PathAndStream pathAndStream) {
    if (pathAndStream == null
        || pathAndStream.filePath() == null
        || pathAndStream.stream() == null) {
      throw new RuntimeException("critical error there is no file provided to parse");
    }
    String fileName = pathAndStream.filePath().getFileName().toString();
    if (isArchive(fileName)) {
      return new ZipProfileProvider(new ProfileJSONParser(), new UnzipperImpl(), pathAndStream);
    }
    return new JsonTextProfileProvider(pathAndStream);
  }

  /**
   * factory method for the Parsing a profile.json for creating a reproduction script
   *
   * @param records number or records to generated for PDSs
   * @return a strategy to handle parsing profiles and turning them into useful objects
   */
  public static ReproProfileParserImpl getReproProfile(
      final long records, final ColumnDefYaml columnDefYaml) {
    return new ReproProfileParserImpl(
        columnDefYaml,
        new SortTableDependencies(),
        new TableRefFinder(),
        new ArrowFormatDeserializer(records, columnDefYaml));
  }
}
